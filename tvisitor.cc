/***************************************
 *                                                                * 
 * Tree Visitor                                               *
 *                                                                *
 * It includes:                                               *
 *                                                               *
 * 1) the Derivation Tree Render  and              *
 *                                                               *
 * 2) the Code Generator                               *
 *                                                               *
 * It follows the Visitor pattern                        *
 *                                                               *
 * Author: Angel Zúñiga                                 *
 * email: azunigac@iingen.unam.mx                *
 *                                                               *
 *                                                               *
 * Date: October 2019                                   *
 *                                                               *
 ***************************************/

/**
 *  Note: the code generated by the compiler are based on the
 *  Contiki and Contiki-NG examples programs available at:
 *
 * https://github.com/contiki-os/contiki
 * http://anrg.usc.edu/contiki/images/a/a8/Sensor-acq.docx
 * https://github.com/contiki-ng/contiki-ng
 *
 * which are released under the 3-clause BSD license.

 * Copyright (c) (Year), (Name of copyright holder)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */


#include "tvisitor.h"
#include <fstream>
#include <sstream> 
#include <string>
#include <cstdlib>

using std::ofstream;
using std::stringstream;
using std::string;


/* Print Visitor */
void PVisitor::visit(MSNode* n){
  cout << "(S ";
  n->getFChild()->pass(*this);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
  }
  if(n->hasTChild()){
    n->getTChild()->pass(*this);
  }
  cout << ")";
  cout << endl;
}

void PVisitor::visit(MSBNode* n){
  cout << "(SB ";
  n->getFChild()->pass(*this);
  n->getSChild()->pass(*this);
  cout << ")";
}

void PVisitor::visit(MWHPNode* n){
  cout << "(WHP ";
  n->getFChild()->pass(*this);
  cout << ")";
}

void PVisitor::visit(MNPNode* n){
  cout << "(NP ";
  n->getFChild()->pass(*this);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
  }
  cout << ")";
}

void PVisitor::visit(MSRNode* n){
  cout << "(SR ";
  n->getFChild()->pass(*this);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
  }
  if(n->hasTChild()){
    n->getTChild()->pass(*this);
  }
    cout << ")";
}


void PVisitor::visit(MNomNode* n){
  cout << "(Nom ";
  n->getFChild()->pass(*this);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
  }
  cout << ")";
}

void PVisitor::visit(MVPNode* n){
  cout << "(VP ";
  n->getFChild()->pass(*this);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
  }
  if(n->hasTChild()){
    n->getTChild()->pass(*this);
  }
  cout << ")";
}

void PVisitor::visit(MCVNode* n){
  cout << "(CV ";
  n->getFChild()->pass(*this);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
  }
  if(n->hasTChild()){
    n->getTChild()->pass(*this);
  }
  cout << ")";
}

void PVisitor::visit(MPPNode* n){
  cout << "(PP ";
  n->getFChild()->pass(*this);
  n->getSChild()->pass(*this);
  cout << ")";
}

void PVisitor::visit(MNNode* n){
  cout << "(Noun \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MDNode* n){
  cout << "(Det \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MJNode* n){
  cout << "(Adj \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MRNode* n){
  cout << "(Adv \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MCNode* n){
  cout << "(Conj \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MCCNode* n){
  cout << "(Coord conj \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MVNode* n){
  cout << "(Verb \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MPrNode* n){
  cout << "(Preposition \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MWRNode* n){
  cout << "(Wh-Adv \"" << n->getWord() << "\") ";
}

void PVisitor::visit(MCMNode* n){
  cout << "(Comma \"" << n->getWord() << "\") ";
}



/* Derivation Tree Visitor */
void DTVisitor::visit(MSNode* n){
  Agnode_t* gn = agnode(G,NULL,TRUE);
  agsafeset(gn,strdup("label"),strdup("S"),strdup(""));
  n->getFChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
    agedge(G,gn,c,NULL,TRUE);
  }
  if(n->hasTChild()){
    n->getTChild()->pass(*this);
    agedge(G,gn,c,NULL,TRUE);
  }
  c = gn;
}

void DTVisitor::visit(MSBNode* n){
  Agnode_t* gn = agnode(G,NULL,TRUE);
  agsafeset(gn,strdup("label"),strdup("SB"),strdup(""));
  n->getFChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  n->getSChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  c = gn;
}


void DTVisitor::visit(MWHPNode* n){
  Agnode_t* gn = agnode(G,NULL,TRUE);
  agsafeset(gn,strdup("label"),strdup("WHP"),strdup(""));
  n->getFChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  c = gn;
}

void DTVisitor::visit(MNPNode* n){
  Agnode_t* gn = agnode(G,NULL,TRUE);
  agsafeset(gn,strdup("label"),strdup("NP"),strdup(""));
  n->getFChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
    agedge(G,gn,c,NULL,TRUE);
  }
  c = gn;
}

void DTVisitor::visit(MNomNode* n){
  Agnode_t* gn = agnode(G,NULL,TRUE);
  agsafeset(gn,strdup("label"),strdup("Nom"),strdup(""));
  n->getFChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
    agedge(G,gn,c,NULL,TRUE);
  }
  c = gn;
}

void DTVisitor::visit(MVPNode* n){
  Agnode_t* gn = agnode(G,NULL,TRUE);
  agsafeset(gn,strdup("label"),strdup("VP"),strdup(""));
  n->getFChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
    agedge(G,gn,c,NULL,TRUE);
  }
  if(n->hasTChild()){
    n->getTChild()->pass(*this);
    agedge(G,gn,c,NULL,TRUE);
  }
  c = gn;
}

void DTVisitor::visit(MCVNode* n){
  Agnode_t* gn = agnode(G,NULL,TRUE);
  agsafeset(gn,strdup("label"),strdup("CV"),strdup(""));
  n->getFChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  n->getSChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  n->getTChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  c = gn;
}

void DTVisitor::visit(MPPNode* n){
  Agnode_t* gn = agnode(G,NULL,TRUE);
  agsafeset(gn,strdup("label"),strdup("PP"),strdup(""));
  n->getFChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  n->getSChild()->pass(*this);
  agedge(G,gn,c,NULL,TRUE);
  c = gn;  
}

void DTVisitor::visit(MNNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "Noun \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}

void DTVisitor::visit(MDNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "Det \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}

void DTVisitor::visit(MJNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "Adj \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}

void DTVisitor::visit(MRNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "Adv \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}

void DTVisitor::visit(MCCNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "CConj \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}

void DTVisitor::visit(MVNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "Verb \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}

void DTVisitor::visit(MPrNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "Preposition \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}

void DTVisitor::visit(MWRNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "Wh-Adv \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}

void DTVisitor::visit(MCMNode* n){
  c = agnode(G,NULL,TRUE);
  string s = "Comma \"" + n->getWord() + "\"";
  agsafeset(c,strdup("label"),strdup(s.c_str()),strdup(""));
}


void DTVisitor::printTree(){
  GVC_t* gvc = gvContext();
  gvLayout(gvc,G,"dot");

  gvRenderFilename(gvc,G,"png",oftname.c_str());
  gvFreeLayout(gvc,G);

  agclose(G);
  gvFreeContext(gvc);
}



/* Code Generator Visitor */

static const int aftctk = string("#include \"contiki.h\"\n\n").length();
static const int bfrpthrd = aftctk + string("PROCESS(process, \"Process\");\n"
					    "AUTOSTART_PROCESSES(&process);\n\n").length();


void CGVisitor::visit(MSBNode* n){
  cg += "#include \"contiki.h\"\n\n"
    "PROCESS(process, \"Process\");\n"
    "AUTOSTART_PROCESSES(&process);\n\n"
    "PROCESS_THREAD(process, ev, data){\n";
  il += "\t";
  cg += il +  "PROCESS_BEGIN();\n";

  Node* tmp = n->getSChild()->getFChild()->getFChild();

  string s("");
  s = tmp->getFChild()->getWord();
  s += " ";

  if(tmp->hasSChild()){
    tmp = tmp->getSChild();

    if(tmp->hasFChild()){
      s += tmp->getFChild()->getWord();
      s += " ";
    }
    if(tmp->hasSChild()){
      s += tmp->getSChild()->getFChild()->getWord();
    }
  }

  if(s == "pressing the button"){
    cg.insert(aftctk,"#include \"dev/button-sensor.h\"\n\n");
    cg += il + "SENSORS_ACTIVATE(button_sensor);\n";
    cg += il + "while(1){\n";
    il += "\t";
    cg += il + "PROCESS_WAIT_EVENT();\n" +
      il + "if( (ev = sensors_event) && (data == &button_sensor) ){\n";
    il += "\t";
  }else{
    cout << "Error" << endl;
    exit(EXIT_FAILURE);
  }

  n->getSChild()->getTChild()->getFChild()->pass(*this);

  il = il.substr(0, il.length()-1);
  cg += il + "}\n";
  il = il.substr(0, il.length()-1);
  cg += il + "}\n";
  cg += il + "PROCESS_END();\n";
  il = il.substr(0, il.length()-1);
  cg += il + "}";

  os << cg;
}

void CGVisitor::visit(MWHPNode* n){

}

void CGVisitor::visit(MSNode* n){
  cg += "#include \"contiki.h\"\n\n"
    "PROCESS(process, \"Process\");\n"
    "AUTOSTART_PROCESSES(&process);\n\n"
    "PROCESS_THREAD(process, ev, data){\n";
  il += "\t";
  cg += il +  "PROCESS_BEGIN();\n";

  n->getFChild()->pass(*this);

  cg += il + "PROCESS_END();\n";
  il = il.substr(0, il.length()-1);
  cg += il + "}";

  os << cg;
  
}

void CGVisitor::visit(MVPNode* n){
  n->getFChild()->pass(*this);
  if(n->hasSChild()){
    n->getSChild()->pass(*this);
  }
  if(n->hasTChild()){
    n->getTChild()->pass(*this);
  }

}

void CGVisitor::visit(MCVNode* n){
  n->getFChild()->pass(*this);
  n->getSChild()->pass(*this);
  n->getTChild()->pass(*this);
}

void CGVisitor::visit(MVNode* n){
  string v = n->getWord();
  if( (v == "Turn") || (v == "turn") ){
    cg.insert(aftctk,"#include \"dev/leds.h\"\n\n");
    
    cg += il + "leds_on(";
  }
  else if( (v == "Measure") || (v == "measure")){
    cg.insert(aftctk,"#include <stdio.h>\n\n");
    
    cg += il + "static int val = 0;\n";
    cg += il + "static float s = 0;\n";
    cg += il + "static int dec = 0;\n";
    cg += il + "static float frac = 0;\n";	      
    cg += il + "SENSORS_ACTIVATE(";
  }
  else if( (v == "Send") || (v == "send")){
    cg.insert(bfrpthrd,"static void udp_rx_callback(struct simple_udp_connection *c,\n"
	      "                               const uip_ipaddr_t *sender_addr,\n"
	      "                               uint16_t sender_port,\n"
	      "                               const uip_ipaddr_t *receiver_addr,\n"
	      "                               uint16_t receiver_port,\n"
	      "                               const uint8_t *data,\n"
	      "                               uint16_t datalen){\n\n"+
	      il + "LOG_INFO(\"Received response '%.*s' from \", datalen, (char *) data);\n" +
	      il + "LOG_INFO_6ADDR(sender_addr);\n" +
	      "#if LLSEC802154_CONF_ENABLED\n" +
	      il + "LOG_INFO_(\" LLSEC LV:%d\", uipbuf_get_attr(UIPBUF_ATTR_LLSEC_LEVEL));\n" +
	      "#endif\n" +
	      il + "LOG_INFO_(\"\\n\");\n\n" +
	      "}\n\n"
      );

    
    cg.insert(aftctk, "#include \"net/routing/routing.h\"\n"
	      "#include \"random.h\"\n"
	      "#include \"net/netstack.h\"\n"
	      "#include \"net/ipv6/simple-udp.h\"\n\n"
	      "#include \"sys/log.h\"\n"
	      "#define LOG_MODULE \"App\"\n"
	      "#define LOG_LEVEL LOG_LEVEL_INFO\n\n"
	      "#define WITH_SERVER_REPLY  1\n"
	      "#define UDP_CLIENT_PORT	8765\n"
	      "#define UDP_SERVER_PORT	5678\n"
	      "#define SEND_INTERVAL (20 * CLOCK_SECOND)\n\n"
	      "static struct simple_udp_connection udp_conn;\n\n"
	      );


    cg += il + "static struct etimer periodic_timer;\n" +
      il + "static unsigned count;\n" +
      il + "static char str[32];\n" +
      il + "uip_ipaddr_t dest_ipaddr;\n\n" +

      il + "simple_udp_register(&udp_conn, UDP_CLIENT_PORT, NULL,\n" +
      il + "                       UDP_SERVER_PORT, udp_rx_callback);\n" +
      
      il + "etimer_set(&periodic_timer, random_rand() % SEND_INTERVAL);\n" +
      il + "while(1) {\n";
    il += "\t";
    cg += il + "PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&periodic_timer));\n" +

      il + "if(NETSTACK_ROUTING.node_is_reachable() && NETSTACK_ROUTING.get_root_ipaddr(&dest_ipaddr)) {\n";
    il += "\t";
      
      cg += il + "LOG_INFO(\"Sending request %u to \", count);\n" +
	il + "LOG_INFO_6ADDR(&dest_ipaddr);\n" +
	il + "LOG_INFO_(\"\\n\");\n" +
	il + "snprintf(str, sizeof(str), \"hello %d\", count);\n" +
	il + "simple_udp_sendto(&udp_conn, str, strlen(str), &dest_ipaddr);\n" +
	il + "count++;\n";
      il = il.substr(0, il.length()-1);
      cg += il + "} else {\n";
      il += "\t";
      cg += il + "LOG_INFO(\"Not reachable yet\");\n";
      il = il.substr(0, il.length()-1);
      cg += il + "}\n" +
	il + "etimer_set(&periodic_timer, SEND_INTERVAL\n" +
	il + "                - CLOCK_SECOND + (random_rand() % (2 * CLOCK_SECOND)));\n";
      il = il.substr(0, il.length()-1);
      cg += il + "}\n";

  }
  else if( (v == "Receive") || (v == "receive")){
    cg.insert(bfrpthrd, "static void udp_rx_callback(struct simple_udp_connection *c,\n"
	      "                                const uip_ipaddr_t *sender_addr,\n"
	      "                                uint16_t sender_port,\n"
	      "                                const uip_ipaddr_t *receiver_addr,\n"
	      "                                uint16_t receiver_port,\n"
	      "                                const uint8_t *data,\n"
	      "                                uint16_t datalen){\n\n" +
	      il + "LOG_INFO(\"Received request '%.*s' from \", datalen, (char *) data);\n" +
	      il + "LOG_INFO_6ADDR(sender_addr);\n" +
	      il + "LOG_INFO_(\"\\n\");\n" +
	      il + "LOG_INFO(\"Sending response.\\n\");\n" +
	      il + "simple_udp_sendto(&udp_conn, data, datalen, sender_addr);\n" +
	      "}\n\n"
      );

    cg.insert(aftctk,"#include \"net/routing/routing.h\"\n"
	      "#include \"net/netstack.h\"\n"
	      "#include \"net/ipv6/simple-udp.h\"\n\n"
	      "#include \"sys/log.h\"\n"
	      "#define LOG_MODULE \"App\"\n"
	      "#define LOG_LEVEL LOG_LEVEL_INFO\n\n"
	      "#define WITH_SERVER_REPLY  1\n"
	      "#define UDP_CLIENT_PORT	8765\n"
	      "#define UDP_SERVER_PORT	5678\n\n"
	      "static struct simple_udp_connection udp_conn;\n\n"
	      );
    cg += il + "NETSTACK_ROUTING.root_start();\n" +
      il + "simple_udp_register(&udp_conn, UDP_SERVER_PORT, NULL,\n" +
      il + "                              UDP_CLIENT_PORT, udp_rx_callback);\n";
    
  }else if (v == "reply"){

  }
  else{
    cout << "Error: No meaning defined for this action: " << v << endl;
    exit(EXIT_FAILURE);
  }
}

void CGVisitor::visit(MPPNode* n){
  n->getSChild()->pass(*this);
}

void CGVisitor::visit(MPrNode* n){

}

void CGVisitor::visit(MNPNode* n){
  n->getFChild()->pass(*this);

  if(n->hasSChild()){
    n->getSChild()->pass(*this);
  }
  
}

void CGVisitor::visit(MDNode* n){

}

void CGVisitor::visit(MNomNode* n){
  string nom = n->getFChild()->getWord();

  if(n->hasSChild()){
    nom += " " + n->getSChild()->getWord();
  }

  if((nom == "light") || (nom == "led") ){//default case
    cg += "LEDS_RED);\n";
  }
  else if((nom == "red light") || (nom =="red led")){
    cg += "LEDS_RED);\n";
  }
  else if((nom == "green light") || (nom == "green led")){
    cg += "LEDS_GREEN);\n";
  }
  else if((nom == "blue light") || (nom == "blue led")){
    cg += "LEDS_BLUE);\n";
  }

  if(nom == "temperature"){
    cg.insert(aftctk,"#include \"dev/sht11/sht11-sensor.h\"\n");
    cg += "sht11_sensor);\n";
    cg += il + "val = sht11_sensor.value(SHT11_SENSOR_TEMP);\n";
    cg += il + "s= ((0.01*val) - 39.60);\n";
    cg += il + "dec = s;\n";
    cg += il + "frac = s - dec;\n";
    cg += il + "printf(\"The temperature is: %d.%02u C (%d)\\n\",dec, (unsigned int)(frac * 100),val);\n";
    cg += il + "SENSORS_DEACTIVATE(sht11_sensor);\n";
  }
  else if(nom == "humidity"){
    cg.insert(aftctk,"#include \"dev/sht11/sht11-sensor.h\"\n"
      "#include <math.h>\n");
    cg += "sht11_sensor);\n";
    cg += il + "val = sht11_sensor.value(SHT11_SENSOR_HUMIDITY);\n";
    cg += il + "s= (((0.0405*val) - 4) + ((-2.8 * 0.000001)*(pow(val,2))));\n";
    cg += il + "dec = s;\n";
    cg += il + "frac = s - dec;\n";
    cg += il + "printf(\"The humidity is: %d.%02u %% (%d)\\n\", dec, (unsigned int)(frac * 100),val);\n";
    cg += il + "SENSORS_DEACTIVATE(sht11_sensor);\n";
  }
  else if(nom == "luminosity"){
    cg.insert(aftctk,"#include \"dev/light-sensor.h\"\n");
    cg += "light_sensor);\n";
    cg += il + "val = light_sensor.value(LIGHT_SENSOR_TOTAL_SOLAR);\n";
    cg += il + "s = (float)(val * 0.4071);\n";
    cg += il + "dec = s;\n";
    cg += il + "frac = s - dec;\n";
    cg += il + "printf(\"The luminosity is: %d.%02u lux (%d)\\n\", dec, (unsigned int)(frac * 100),val);\n";
    cg += il + "SENSORS_DEACTIVATE(sht11_sensor);\n";
  }

  
}

void CGVisitor::visit(MJNode* n){

}

void CGVisitor::visit(MRNode* n){

}

void CGVisitor::visit(MCCNode* n){

}

void CGVisitor::visit(MNNode* n){

}

void CGVisitor::visit(MWRNode* n){

}

void CGVisitor::visit(MCMNode* n){

}

